type PoolFactory @entity {
  id: ID! # PoolFactory contract address
  poolCount: BigInt! # Listed pools count
  tokenCount: BigInt! # Listed tokens count
  spartaDerivedUSD: BigDecimal!
  tvlSPARTA: BigDecimal!
  tvlUSD: BigDecimal!
}

type Token @entity {
  id: ID! # Token contract address
  symbol: String!
  name: String!
  decimals: BigInt!
  pool: Pool! # Pool contract address
}

type Pool @entity {
  id: ID! # Pool contract address
  token0: Token! # Token contract address
  genesis: BigInt! # Timestamp of pool creation
  symbol: String!
  name: String!
  decimals: BigInt!
  totalSupply: BigDecimal!
  baseAmount: BigDecimal! # SPARTA balance
  tokenAmount: BigDecimal! # TOKEN balance
  fees: BigDecimal! # Slip fees paid into the pool
  feesUSD: BigDecimal!
  incentives: BigDecimal! # Incentives paid into the pool (divis, realises etc)
  incentivesUSD: BigDecimal!
  stablecoin: Boolean! # If true; can be used for internally deriving USD pricing
  tvlSPARTA: BigDecimal!
  tvlUSD: BigDecimal!
  liqAdds: [LiqAdd!]! @derivedFrom(field: "pool")
  liqRemoves: [LiqRemove!]! @derivedFrom(field: "pool")
  swaps: [Swap!]! @derivedFrom(field: "pool")
  mintSynths: [MintSynth!]! @derivedFrom(field: "pool")
  burnSynths: [BurnSynth!]! @derivedFrom(field: "pool")
}

type Member @entity {
  # Add in a running NET sum of add/removes etc to get a position without having to call any arrays (USD/SPARTA/etc)
  id: ID! # Member's wallet address
  fees: BigDecimal! # Slip fees paid into the pools
  liqNetSparta: BigDecimal!
  liqNetUSD: BigDecimal!
  netHarvestSparta: BigDecimal!
  netHarvestUSD: BigDecimal!
  netRealisedSparta: BigDecimal!
  netRealisedUSD: BigDecimal!
  liqAdds: [LiqAdd!]! @derivedFrom(field: "member")
  liqRemoves: [LiqRemove!]! @derivedFrom(field: "member")
  swaps: [Swap!]! @derivedFrom(field: "member")
  mintSynths: [MintSynth!]! @derivedFrom(field: "member")
  burnSynths: [BurnSynth!]! @derivedFrom(field: "member")
  harvests: [Harvest]! @derivedFrom(field: "member")
  bonds: [Bond]! @derivedFrom(field: "member")
}

type Transaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt! # block txn was included in
  timestamp: BigInt! # timestamp txn was confirmed
  gasUsed: BigInt! # gas used during txn execution
  gasPrice: BigInt!
  liqAdds: [LiqAdd]! @derivedFrom(field: "transaction")
  liqRemoves: [LiqRemove]! @derivedFrom(field: "transaction")
  swaps: [Swap]! @derivedFrom(field: "transaction")
  mintSynths: [MintSynth]! @derivedFrom(field: "transaction")
  burnSynths: [BurnSynth]! @derivedFrom(field: "transaction")
  harvests: [Harvest]! @derivedFrom(field: "transaction")
  bonds: [Bond]! @derivedFrom(field: "transaction")
}

type LiqAdd @entity {
  id: ID! # TxnHash + logIndex
  transaction: Transaction!
  logIndex: BigInt
  timestamp: BigInt! # timestamp of transaction
  pool: Pool!
  token: Token!
  member: Member!
  origin: Bytes!
  inputBase: BigDecimal!
  inputToken: BigDecimal!
  unitsIssued: BigDecimal!
  derivedSparta: BigDecimal!
  derivedUSD: BigDecimal!
}

type LiqRemove @entity {
  id: ID! # TxnHash + logIndex
  transaction: Transaction!
  logIndex: BigInt
  timestamp: BigInt! # timestamp of transaction
  pool: Pool!
  token: Token!
  member: Member!
  origin: Bytes!
  inputLPs: BigDecimal!
  outputToken: BigDecimal!
  outputSparta: BigDecimal!
  derivedSparta: BigDecimal!
  derivedUSD: BigDecimal!
}

type Swap @entity {
  id: ID! # TxnHash + logIndex
  transaction: Transaction!
  logIndex: BigInt
  timestamp: BigInt! # timestamp of transaction
  pool: Pool!
  token: Token!
  member: Member!
  origin: Bytes!
  fromSparta: Boolean!
  input: BigDecimal!
  output: BigDecimal!
  derivedSparta: BigDecimal!
  derivedUSD: BigDecimal!
}

type MintSynth @entity {
  id: ID! # TxnHash + logIndex
  transaction: Transaction!
  logIndex: BigInt
  timestamp: BigInt! # timestamp of transaction
  pool: Pool!
  token: Token!
  member: Member!
  origin: Bytes!
  inputSparta: BigDecimal!
  mintedSynths: BigDecimal!
  derivedUSD: BigDecimal!
}

type BurnSynth @entity {
  id: ID! # TxnHash + logIndex
  transaction: Transaction!
  logIndex: BigInt
  timestamp: BigInt! # timestamp of transaction
  pool: Pool!
  token: Token!
  member: Member!
  origin: Bytes!
  outputSparta: BigDecimal!
  burnedSynths: BigDecimal!
  derivedUSD: BigDecimal!
}

type Harvest @entity {
  id: ID! # TxnHash + logIndex
  transaction: Transaction!
  logIndex: BigInt
  timestamp: BigInt! # timestamp of transaction
  member: Member!
  origin: Bytes!
  derivedSparta: BigDecimal!
  derivedUSD: BigDecimal!
}

type Bond @entity {
  id: ID! # TxnHash + logIndex
  transaction: Transaction!
  logIndex: BigInt
  timestamp: BigInt! # timestamp of transaction
  pool: Pool!
  token: Token!
  member: Member!
  origin: Bytes!
  inputToken: BigDecimal!
  unitsIssued: BigDecimal!
  derivedSparta: BigDecimal!
  derivedUSD: BigDecimal!
}

type MetricsGlobalDay @entity {
  id: ID! # Timestamp
  timestamp: BigInt! # Timestamp of start of day (timestamp / 86400 -> rounded * 86400)
  volSPARTA: BigDecimal! # Daily volume in SPARTA
  volUSD: BigDecimal! # Daily volume in USD
  fees: BigDecimal! # Daily slip fees in SPARTA
  feesUSD: BigDecimal! # Daily slip fees in USD (derived internally)
  txCount: BigInt! # Daily txns
  tvlSPARTA: BigDecimal!
  tvlUSD: BigDecimal!
}

type MetricsPoolDay @entity {
  id: ID! # Pool address + Timestamp
  timestamp: BigInt! # Timestamp of start of day (timestamp / 86400 -> rounded * 86400)
  pool: Pool!
  volSPARTA: BigDecimal! # Daily volume in SPARTA
  volUSD: BigDecimal! # Daily volume in USD
  fees: BigDecimal! # Daily slip fees in SPARTA
  feesUSD: BigDecimal! # Daily slip fees in USD (derived internally)
  txCount: BigInt! # Daily txns
  tvlSPARTA: BigDecimal!
  tvlUSD: BigDecimal!
}
